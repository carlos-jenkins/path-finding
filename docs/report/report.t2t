Título del documento
Autores
%%date(%B, %Y)

%!target: tex
%!style(xhtmls): media/themes/Clean/style.css
%!nested(xhtmls): --libs syntaxhighlighter
%!options(tex): --enum-title --toc --toc-level 5
%!nested(tex): --docclass {article} --pdf

%S = Tabla de contenidos =[tabla_de_contenidos]

%Tabla de contenidos
%%toc

%tex% '''
%tex% \listoftables
%tex% \listoffigures
%tex% \newpage
%tex% '''

= Descripción del problema =[descripcion_del_problema]

Los algoritmos de búsqueda se utilizan constantemente en aplicaciones de IA tales como robótica.
En estos contextos, sin embargo, es importante adaptar dichos algoritmos a un entorno dinámico. 
Es común, por ejemplo, que el agente tenga que responder en un marco de tiempo limitado, que tenga 
que movilizarse físicamente para encontrar las rutas, y que en general se encuentre trabajando en linea. @@
En la presente tarea se describe la implementación de tres algoritmos clásicos de búsqueda:

- Greedy (Best-First-Search).
- A* (A estrella).
- Jump points search.


A continuación se presenta la descripción de la solución (modificaciones al servidor gráfico, funciones 
generales y descripción de los algoritmos de búsqueda) y el análisis de resultados de la implementación.

= Descripción de la solución =[descripcion_de_la_solucion]



== Modificaciones al servidor gráfico ==[modificaciones_al_servidor_grafico]

Para el presente proyecto se utilizó una cuadrícula gráfica desarrollada por el profesor en el archivo ``board.erl``.
El API de dicha cuadrícula está presente en la especificación del proyecto y consiste en:

	``> board:start().``

Que inicia la interfaz gráfica y permite configurar el entorno, en particular guardar y salvar archivos.

	``> board ! {get_pos, self()}.``

Se obtiene la posición del agente en un tupla ``{X, Y}``.

	``> board ! {move, {X, Y}}.``

Mueve el agente a la posición ``{X, Y}``. Dicha posición debe estar en el //Fringe// del algoritmo. Útil para los
algoritmos Greedy y A* pero no para el Jump Points.

	``> board ! {get_neigbors, self()}.``

Obtiene los vecinos del nodo actual en el que se ubica el agente. Devuelve una tupla de dos listas, la primera
contiene las tuplas de los vecinos y la segunda la heurística euclidiana asociada a cada uno. Es de la forma:

	``{[{X1, Y1}, {X2, Y2}], [0.1, 0.2]}``

Para poder implementar los algoritmos del presente proyecto se agregaron dos llamadas al servidor gráfico:

	``> board ! {jump, {X, Y}}.``

Mueve al agente a la posición ``{X, Y}``. La posición no necesariamente debe estar en el //Fringe//. Es utilizada
por el algoritmo Jump Points.

	``> board ! {get_finish, self()}.``

Obtiene una tupla ``{X, Y}`` con la posición del destino. Es utilizado por todos los algoritmos para saber cuando
deben terminar.

Además, se tuvo que modificar la función de la cuadrícula ``neighbors()`` para que devolviera el punto de finalización
en los vecinos, pues anteriormente lo excluía lo que dificultaba los algoritmos Greedy y A* para saber cuando han llegado
al destino. La función modificada quedó de la siguiente forma:

{{{ erlang
neighbors(_,_,[]) -> [];
neighbors(Board,Cell={R,C},[{OR,OC}|Rest]) ->
    Pos = calcPos(R+OR,C+OC),
    if
    Pos == invalid -> neighbors(Board, Cell, Rest);
    true ->
        case element(Pos, Board) of
        ?EMPTY ->
            [{R+OR,C+OC}|neighbors(Board, Cell, Rest)];
        ?FINISH ->
            [{R+OR,C+OC}|neighbors(Board, Cell, Rest)];
        _ ->
            neighbors(Board, Cell, Rest)
        end
    end.
}}}

== Funciones de utilidad general ==[funciones_de_utilidad_general]



== Descripción de algoritmos ==[descripcion_de_algoritmos]



=== Greedy ===[greedy]



=== A* ===[a]



=== Jump Points ===[jump_points]




%tex% ''' \newpage

= Análisis de resultados =[analisis_de_resultados]

El resumen de implementación de la presente tarea es el siguiente:

%tex% ''' \begin{table}[H]
||   Algoritmo   |  Implementado  |
 |    Greedy     |       Si       |
 |      A*       |       Si       |
 |  Jump points  |       Si       |
%tex% ''' \caption{Perspectiva del producto por desarrollar.}\end{table}

Para las pruebas se utilizaron tres mapas generados por el equipo de trabajo. Dichos
mapas de prueba pueden ser ubicados en el repositorio en:

	``/tests/test*.map``

Los tres mapas son crecientes en dificultad. A continuación se incluye una captura de pantalla
de cada algoritmo corriendo en cada uno de los mapas de prueba.

== Mapa1 ==[mapa1]



=== Greedy en mapa 1 ===[greedy_en_mapa_1]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test1_greedy.png]
%tex% ''' \caption{Ejecución del algoritmo greedy en el mapa de prueba 1.}\end{center}\end{figure}

=== A* en mapa 1 ===[a_en_mapa_1]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test1_a_star.png]
%tex% ''' \caption{Ejecución del algoritmo A* en el mapa de prueba 1.}\end{center}\end{figure}

=== Jump points en mapa 1 ===[jump_points_en_mapa_1]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test1_jump_points.png]
%tex% ''' \caption{Ejecución del algoritmo Jump Points en el mapa de prueba 1.}\end{center}\end{figure}

== Mapa2 ==[mapa2]



=== Greedy en mapa 2 ===[greedy_en_mapa_2]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test2_greedy.png]
%tex% ''' \caption{Ejecución del algoritmo greedy en el mapa de prueba 2.}\end{center}\end{figure}

=== A* en mapa 2 ===[a_en_mapa_2]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test2_a_star.png]
%tex% ''' \caption{Ejecución del algoritmo A* en el mapa de prueba 2.}\end{center}\end{figure}

=== Jump points en mapa 2 ===[jump_points_en_mapa_2]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test2_jump_points.png]
%tex% ''' \caption{Ejecución del algoritmo Jump Points en el mapa de prueba 2.}\end{center}\end{figure}

== Mapa3 ==[mapa3]



=== Greedy en mapa 3 ===[greedy_en_mapa_3]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test3_greedy.png]
%tex% ''' \caption{Ejecución del algoritmo greedy en el mapa de prueba 3.}\end{center}\end{figure}

=== A* en mapa 3 ===[a_en_mapa_3]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test3_a_star.png]
%tex% ''' \caption{Ejecución del algoritmo A* en el mapa de prueba 3.}\end{center}\end{figure}

=== Jump points en mapa 3 ===[jump_points_en_mapa_3]

%tex% ''' \begin{figure}[H]\begin{center}
[450-test3_jump_points.png]
%tex% ''' \caption{Ejecución del algoritmo Jump Points en el mapa de prueba 3.}\end{center}\end{figure}

%tex% ''' \newpage

= Conclusiones =[conclusiones]

- El algoritmo Greedy es el segundo más rápido y es siempre encuentra una ruta, sin embargo, la ruta encontrada
  no es necesariamente la óptima. En la figura 1 del análisis de resultados se puede observar cómo el Greedy
  encuentra una ruta rápidamente pero ésta no es la óptima (la óptima sería irse por la apertura superior).

- El algoritmo Greedy necesita recordar todo el //Fringe// de la búsqueda para poder hacer el backtracking, lo 
  que implica un //memory overhead// importante para problemas grandes.

- El algoritmo A* es el más lento de todos, sin embargo garantiza que la ruta encontrada sea la óptima. Como se
  puede observar en la figura 2, 5 y 8 el A* encuentra la ruta óptima pero al costo de una búsqueda más intensa.

- Al algoritmo A*, al igual que el Greedy tiene un //memory overhead// importante en problemas grandes pues también
  requiere recordar el //Fringe// de todo el recorrido.

- El algoritmo Jump Points es el más rápido y eficiente, sin embargo es el de mayor complejidad y requiere una lógica
  mucho más compleja. Al ser muy reciente (publicado en 2011) existen pocos artículos, implementaciones, tutoriales
  o explicaciones en relación a los dos anteriores, lo que dificulta la comprensión e implementación.

- El algoritmo Jump Points, a diferencia del Greedy y el A* no tiene un //memory overhead// importante pues no requiere
  recordar todo el //Fringe// y lo que requiere recordar es la lista de nodos de salto abiertos y los cerrados, lo cual 
  es mínimo en comparación con la cantidad de nodos del //Fringe//.

- El algoritmo Jump Points al igual que el A* garantiza encontrar la ruta óptima y en menos tiempo (según el artículo hasta
  10 veces mas rápido).

- Sin embargo, el algoritmo Jump Points sólo funciona en tableros (//grids//) uniformes de costo no variable entre saltos o
  casillas y bidireccionales, a diferencia del Greedy y del A* que funcionan en contexto de grafos dirigidos y de peso de
  arcos variable.


%tex% ''' \newpage

= Referencias =[referencias]

- Harabor D. and Grastien A. (2011). //Online graph pruning for pathfinding on grid maps//. 
  In Proceedings of the 25th National Conference on Artificial Intelligence (AAAI), San Francisco, USA.
- Xueqiao, X. (2011). //A comprehensive path-finding library in javascript//. @@
  Retrieved from https://github.com/qiao/PathFinding.js


